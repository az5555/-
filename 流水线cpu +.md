#CPU设计草稿
## PC(程序计数器)
>简介：
每个周期地址+4,输出地址。
端口：
out：输出的地址。(输出信号)(31:0)
clk：时钟信号。
in：下一个pc的地址。(31:0)
reset：异步重置信号，当reset为1时，地址归零。
en:使能信号，但en有效时，才能读入信号。

## NPC
>简介：
计算下一位地址。
端口：
pc：当前pc地址。(31:0)
npc：下一个地址。(输出信号)(31:0)
imm_off:跳转偏移值。(15:0)
imm_j：26位跳转输入地址。(25:0)
jr:32位跳转地址。(31:0)
op简介：
00：当前pc加4作为下一个地址。
01：pc加4加上符号扩展后的偏移值。
10：(31:28)为与原pc相同，imm_j作为低位字节地址。
11:跳转到输入的jr地址。

##GRF(通用寄存器组)
>简介：
32个寄存器组成的寄存器组，其中0号寄存器恒定为0。
端口：
clk：时钟信号。
reset：异步重置信号，当reset为1时，所有寄存器归零。
WE_op：但该端口为高电平时，才能写入数据。
A1：一号地址。(4:0)
A2：二号地址。(4:0)
A3：待写入数据的寄存器的地址。(4:0)
RD1：输出一号地址所对应的寄存器的存储的数据。(输出信号)(31:0)
RD2：输出二号地址所对应的寄存器的存储的数据。(输出信号)(31:0)
WE：要写入的数据。(31:0)

##ALU(算术逻辑单元)
>简介：
提供四种运算。
端口：
ALU_op：输入不同信号进行不同运算。(3:0)
A1：一号运算数。(31:0)
A2：二号运算数。(31:0)
ans：运算结果。(输出信号)(31:0)
ALU_op详细说明；
为0000时：ans = A1 + A2
为0001时：ans = A1 - A2
为0010时：ans = A1 | A2
为0011时：ans = A1 & A2
为0100时：ans = 1(A1 < A2) (无视符号)否则为0
为0101时：ans = 1(A1 < A2) 否则为0

##EXT(扩展单元)
>简介：
提供三种扩展方式。
端口：
in：输入16位数字。(15:0)
out：输出扩展后的32位数字。(输出信号)(31:0)
EXT_op：输入不同信号进行不同运算。(1:0)
EXT_op详细说明；
为00时：高位0拓展。
为01时，地位0拓展。
为10时：高位符号拓展。

##CMP(比较单元)
>简介：比较beq指令是否执行。
端口：
CMP1：第一个比较数。(31:0)
CMP2：第二个比较数。(31:0)
CMP_en：使能信号，该信号为0时，才运行改模块。
j_op:跳转信号。(输出信号)

##D_REG(D级寄存器)
>简介：存储D级所有指令。
端口：
en：当en为1时，寄存器存储的数值恒定不变。

##E_REG(E级寄存器)
>简介：存储E级所有指令。

##M_REG(M级寄存器)
>简介：存储M级所有指令。

##W_REG(W级寄存器)
>简介：存储W级所有指令。

##D_CTRL(D级控制器)
> 输出D级控制信号。
信号说明：
    output [2:0] D_CMP_A1_op
    output [2:0] D_CMP_A2_op
    CMP输入的跳转控制信号
    000：正常输入。
    001：接收E级转发。
    010：接收M级转发。
    output [2:0] D_NPC_JR_op
    jr指令跳转控制信号。
    000：正常输入。
    010：M级转发。

##E_CTRL(E级控制器)
> 输出E级控制信号。
信号说明：
    output [2:0] E_ALU_MUX_A2
    ALU第二接口输入选择信号
    000：输入rt寄存器数值。
    001：输入拓展立即数。
    output [2:0] E_GRF_RD1_op,
    output [2:0] E_GRF_RD2_op,
    RD1和RD2转发控制信号。
    000：正常输入。
    001：接收M级转发。
    010：接收W级ans转发。
    011：接收W级DM_out转发.

##M_CTRL(M级控制器)
> 输出M级控制信号。
信号说明：
    output [1:0] M_DM_op,
    DM写入控制信号
    output [1:0] M_DM_address_mux_op
    DM地址输入控制信号
    00：写入RD1+偏移值
    output [1:0] M_DM_WE_max_op
    DM写入数值控制信号。
    output [2:0] M_GRF_RD2_op
    RD2转发控制信号
    000:正常运行；
    001：接收W级ans转发。
    010：接收W级DW_out转发。

##W_CTRL(W级控制器)
> 输出W级控制信号。
信号说明：
    output W_WE_op
    GRF写入控制信号
    output [1:0] W_grf_address_mux_op,
    GRF地址输入地址控制信号
    00：写入rd寄存器数值。
    01：写入写入rt寄存器数值。
    10：写入31号寄存器。
    output [1:0] W_grf_WE_mux_op,
    GRF写入数值控制信号。
    00：写入ALU计算结果。
    01：写入DM取出的数值。
    10：写入PC+4.

##DM_IN_EXT
>拼装输入数据。
端口说明：
input [31:0] in 输入数据
output [31:0] out 输出数据
input [3:0] EXT_op 选择信号
0000：输出和输出相等
1111：输出和输出相等
0011：out[15:0]位为in[15:0]位，其他为位0。
1100：out[31:16]位为in[15:16]位，其他为位0。
0001：out[7:0]位为in[7:0]位，其他为位0。
0010：out[15:7]位为in[7:0]位，其他为位0。
0100：out[23:16]位为in[7:0]位，其他为位0。
1000：out[31:24]位为in[7:0]位，其他为位0。

##DM_OUT_EXT
>拓展DM的输出数据。
端口说明：
input [31:0] in 输入数据
output [31:0] out 输出数据
input [2:0] EXT_op 选择信号
000：无扩展
001：无符号字节数据扩展
010：符号字节数据扩展
011：无符号半字数据扩展
100：符号半字数据扩展
input [1:0] addr 最低两位地址

##HILO
>乘除法运算单元。
clk 时钟信号。
reset 复位信号。
input [31:0] A1 输入运算数1
input [31:0] A2 输入运算数2
output [31:0] ans 输出结果
input [3:0] HILO_OP 选择指令
input start 开始运算的信号
output busy 表示忙碌
0000：读取HI寄存器。
0001：读取LO寄存器。
0010：写入HI寄存器。
0011：写入LO寄存器。
0100：运行乘法。
0101：运行除法。
0110：运行乘法。（有符号）
0111：运行除法。（有符号）

#测试指令
    ori $a0, $0, 123
    ori $a1, $a0, 456
    lui $a2,0x8000     #测试边界负数
    ori $a2,1          #测试小立即数
    ori $a2,0
    lui $a2,0x7fff    #测试边界正数
    lui $a2,0x7ffe    
    ori $a2,65535      #测试边界立即数
    ori $a2,65533
    ori $a2,12313       #测试随机立即数
    lui $a2, 123            # 符号位为 0
    lui $a3, 0xffff         # 符号位为 1
    ori $0,$0,1020          #测试$0寄存器
    ori $a3, $a3, 0xffff    # $a3 = -1
    add $s0, $a0, $a2      # 正正
    add $s1, $a0, $a3      # 正负
    add $s2, $a3, $a3      # 负负
    sub $s0, $a0, $a2      # 正正
    sub $s1, $a0, $a3      # 正负
    sub $s2, $a3, $a3      # 负负
    ori $t0, $0, 0x0000
    sw $a0, 0($t0)
    sw $a1, 4($t0)
    sw $a2, 8($t0)
    sw $a3, 12($t0)
    sw $s0, 16($t0)
    sw $s1, 20($t0)
    sw $s2, 24($t0)        #测试sw指令
    lw $a0, 0($t0)
    lw $a1, 12($t0)         #测试lw指令
    sw $a0, 28($t0)
    sw $a1, 32($t0)
    ori $a0, $0, 1
    ori $a1, $0, 2
    ori $a2, $0, 1
    beq $a0, $a1, loop1     # 不相等
    beq $a0, $a2, loop2     # 相等
    loop1:sw $a0, 36($t0)
    loop2:sw $a1, 40($t0)
##机械码
    3404007b
    348501c8
    3c068000
    34c60001
    34c60000
    3c067fff
    3c067ffe
    34c6ffff
    34c6fffd
    34c63019
    3c06007b
    3c07ffff
    340003fc
    34e7ffff
    00868020
    00878820
    00e79020
    00868022
    00878822
    00e79022
    34080000
    ad040000
    ad050004
    ad060008
    ad07000c
    ad100010
    ad110014
    ad120018
    8d040000
    8d05000c
    ad04001c
    ad050020
    34040001
    34050002
    34060001
    10850001
    10860001
    ad040024
    ad050028


    p1:
    lui $t2,16
    ori $t1,15
    ori $t2,15
    add $t2,$t2,$t1
    beq $t1,$t2,p1
    sub $t2,$t2,$t1
    jal p2
    sub $t1,$t1,$t1
    sub $t2,$t2,$t2
    p3:
    beq $t1,$t1,p3
    p2:
    ori $t1,17
    ori $t2,17
    jr $ra

    3c0a0010
    3529000f
    354a000f
    01495020
    112afffb
    01495022
    0c000c0a
    01294822
    014a5022
    1129ffff
    35290011
    354a0011
    03e00008

    li	$s0, 0
    li	$s1, -1000
    li	$s2, 1000
    lui	$s3, 0x8000	#s3 is  -2147483648
    lui	$s4, 0x8000
    ori	$s4, 0x0001	#s4 is  -2147483647
    lui	$s5, 0x7fff
    ori	$s5, 0xffff	#s5 is  2147483647
    lui	$s6, 0x7fff
    ori	$s6, 0xfffe	#s6 is 2147483646
    ori $s7,1

    beq_1:	
    beq $s0, $s0,beq_1_test
    beq_2:	
    beq $s1, $s1,beq_2_test

    beq_10:  beq	$s5, $s6, beq_10_test
    beq_end:

    jal_1:	jal	jal_1_test
    jal_5:	jal	jal_5_test
    jal_end:

    sw	$t0, 0($s0)
    sw	$t1, 0($s0)
    sw	$t2, 0($s0)
    sw	$t3, 0($s0)
    sw	$t4, 0($s0)
    sw	$t5, 0($s0)
    loop:
    beq $0,$0,loop
	
    beq_1_test: add	$t0,$t0, $s7
	   beq $0,$0,beq_2
	   
    beq_2_test: add	$t0,$t0, $s7
	   beq $0,$0,beq_10

    beq_10_test: add $t0,$t0, $s7
	   beq $0,$0,beq_end
		
    jal_1_test:	add	$t4, $4, $s7
		jr	$ra

    jal_5_test:	add	$t4, $4, $s7
		jr	$ra

24100000
2411fc18
241203e8
3c138000
3c148000
36940001
3c157fff
36b5ffff
3c167fff
36d6fffe
36f70001
1210000b
1231000c
12b6000d
0c000c1d
0c000c1f
ae080000
ae090000
ae0a0000
ae0b0000
ae0c0000
ae0d0000
1000ffff
01174020
1000fff3
01174020
1000fff2
01174020
1000fff1
00976020
03e00008
00976020
03e00008

    ori $a0,$0,1999  
    ori $a1,$a0,111 
    lui $a2,12345
    lui $a3,0xffff
    lui $t0,0xffff
    beq $a3,$t0,eee
    add $s7,$0,$a0
    nop
    ori $a3,$a3,0xffff
    add $s0,$a0,$a1 
    add $s1,$a3,$a3
    add $s2,$a3,$s0
    beq $s2,$s3,eee
    sub $s0,$a0,$s2 
    sub $s1,$a3,$a3
    eee:
    sub $s2,$a3,$a0
    sub $s3,$s2,$s1
    ori $t0,$0,0x0000
    sw $a0,0($t0)
    nop
    sw $a1,4($t0)
    sw $s0,8($t0)
    sw $s1,12($t0)
    sw $s2,16($t0)
    sw $s5,20($t0)
    lw $t1,20($t0)
    lw $t7,0($t0)
    lw $t6,20($t0)
    sw $t6,24($t0)
    lw $t5,12($t0)
    jal end
    ori $t0,$t0,1
    ori $t1,$t1,1
    ori $t2,$t2,2
    beq $t0,$t2,eee
    lui $t3,1111
    jal out
    end:
    add $t0,$t0,$t7
    jr $ra
    out:
    add $t0,$t0,$t3
    ori $t2,$t0,0
    beq $t0,$t2,qqq
    lui $v0,10
    qqq:
    lui $v0,11
    j www
    nop
    www:
    lui $ra,100

    loop:
    addi $t1,$t1,0x1234
    ddi $t2,$t2,0x1234
    andi $t2,$t2,0x1234
    and $t2,$t2,0x1234
    bne $t1,$t2,loop
    addi $t3,$t2,0x4321
    or $t4,$t2,$t3
    addi $t5,$0,-1
    slt $t6,$t5,$t1
    slt $t6,$t1,$t5
    sltu $t6,$t5,$t1
    sltu $t6,$t5,$t1
    sb $t6,4($t6)
    lb $t7,4($t6)
    add $t6,$t6,$t6
    sh $t6,4($t6)
    lh $t7,4($t6)
    mult $t1,$t5
    mflo $t3
    mfhi $t4
    multu $t1,$t2
    mflo $t3
    mfhi $t4
    div $t1,$t5
    mflo $t3
    mfhi $t4
    divu $t1,$t2
    mflo $t3
    mfhi $t4
    mtlo $t1
    mflo $t1
    mthi $t1
    mfhi $t1
#思考题
1、为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？
>乘除运算指令运算很慢，需要很多周期，运用独立的乘法部件，可以加快CPU运算速度。


2、真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。
>通过多次调用ALU进行加减法来完成乘除法运算。乘法用多次加法，除法用多次减法。

3、请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？
>当乘除法器还在Busy时，若D级指令为乘除法指令时，就阻塞。

4、请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）。
>这样设计符合直觉，更加清晰，同时也方便sb。sh指令的写入，而且与lb，lh等指令统一。

5、请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？
>都不是一字节，

6、为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？
>将opcode和fuc判断先抽象为一个位信号，在变量命名时，加入其所在的流水线位置，运用的单元以及其作用；这样让代码更加有可读性，能够一眼了解数据如何处理，数据流向也更加清楚，同时也能更容易找出错误位置。

7、在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？
>我遇到了mthi指令和运算指令的冲突。我通过转发和阻塞将其解决。
    lw $t1,0($t1)
    mthi $t1


8、如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果
>构造策略是尽可能用到所有指令，并且尽可能运用相同的寄存器，产生尽可能多的数据冲突。